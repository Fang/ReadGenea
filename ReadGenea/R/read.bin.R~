read.bin <-
function (binfile, outfile = NULL, start = NULL, end = NULL, 
    verbose = FALSE, do.temp = TRUE, calibrate = FALSE, gain = NULL, 
    offset = NULL, luxv = NULL, voltv = NULL, tformat = "seconds",warn=FALSE) 
{
    headlines <- 59
    reclength <- 10
    orig.opt <- options(digits.secs = 3)
    fc <- file(binfile, "rt")
    freq <- scan(fc, skip = 19, what = "", n = 2, sep = ":", 
        quiet = TRUE)[2]
    freq <- as.numeric(strsplit(freq, " ")[[1]][1])
    xgain <- as.integer(scan(fc, skip = 27, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    xoffset <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    ygain <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    yoffset <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    zgain <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    zoffset <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    volts <- as.integer(scan(fc, skip = 0, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    lux <- as.integer(scan(fc, skip = 0, what = "", n = 2, sep = ":", 
        quiet = TRUE)[2])
    npages <- as.integer(scan(fc, skip = 2, what = "", n = 2, 
        sep = ":", quiet = TRUE)[2])
    t1 <- scan(fc, skip = 4, what = "", quiet = TRUE, nlines = 1)
    freq <- as.integer(scan(fc, skip = 4, what = "", n = 2, sep = ":", 
        quiet = TRUE)[2])
    if (verbose) {
        cat("Number of pages in binary file:", npages, "\n")
    }
    close(fc)
    nobs <- 300
    freqseq <- seq(0, by = 1/freq, length = nobs)
    timespan <- nobs/freq
    bseq <- seq(headlines, by = reclength, length = npages) - 
        1
    t1 <- t1[2:length(t1)]
    t1[1] <- substr(t1[1], 6, nchar(t1[1]))
    t1c <- reformat.time(t1, format = "POSIX")
    t1 <- reformat.time(t1, format = tformat)
    timestampsc <- seq(t1c, by = timespan, length = npages)
    timestamps <- seq(t1, by = timespan, length = npages)
    tnc <- timestampsc[npages]
    tn <- timestamps[npages]
    if (is.null(start)) {
        start <- 1
    }
    if (is.null(end)) {
        end <- npages
    }
    if (is.numeric(start)) {
        if ((start > npages)) {
            stop(cat("Please input valid start and end times between ", 
                t1c, " and ", tnc, " or pages between 1 and ", 
                npages, ".\n\n"), call. = FALSE)
        } else if (start < 1) {
#specify a proportional point to start
		start = timestamps[max(floor( start * npages),1)]
	} else {
            start <- max(start, 1)
            start <- timestamps[start]
        }
    }
    if (is.numeric(end)) {
        if ((end < 1)) {
#            stop(cat("Please input valid start and end times between ", 
#                t1c, " and ", tnc, " or pages between 1 and ", 
#                npages, ".\n\n"), call. = FALSE)
#specify a proportional point to end
		end= min(end * npages, end)
		end = timestamps[end]
        }
        else {
            end <- min(end, npages)
            end <- timestamps[end]
        }
    }
    if (is.character(start)) {
        start <- reformat.time(start, format = tformat)
    }
    if (is.character(end)) {
        end <- reformat.time(end, format = tformat)
    }
    if (end < start) {
        cat("Warning, specified end time is before specified start time.  Reordering.\n")
        tmp <- end
        end <- start
        start <- tmp
    }
    if ((start > tn) | (end < t1)) {
        stop(cat("Please input valid start and end times between ", 
            t1c, " and ", tnc, " or pages between 1 and ", npages, 
            ".\n\n"), call. = FALSE)
    }
    start <- max(start, t1)
    end <- min(end, tn)
    index <- which((timestamps >= start) & (timestamps <= end))
    d1 <- max(which((timestamps - start) <= 0))
    index <- unique(c(d1, index))
    if (length(index) == 0) {
        d1 <- timestampsc[max(which((timestamps - start) < 0))]
        d2 <- timestampsc[min(which((timestamps - end) > 0))]
        if (npages > 15) {
            stop("No pages to process with specified timestamps.  Please try again.\n", 
                call. = FALSE)
        }
        else {
            stop("No pages to process with specified timestamps.  Please try again.Timestamps in binfile are:\n\n", 
                paste(timestampsc, collapse = " \n"), " \n\n", 
                call. = FALSE)
        }
    }
    if (do.temp) {
        temperature <- NULL
    }
    if (calibrate) {
        if (!is.null(gain)) {
            if (!is.numeric(gain)) {
                stop("Please enter 3 valid values for the x,y,z gains.\n")
            }
            else {
                xgain <- gain[1]
                ygain <- gain[2]
                zgain <- gain[3]
            }
        }
        if (!is.null(offset)) {
            if (!is.numeric(offset)) {
                stop("Please enter 3 valid values for the x,y,z offsets.\n")
            }
            else {
                xoffset <- offset[1]
                yoffset <- offset[2]
                zoffset <- offset[3]
            }
        }
        if (!is.null(voltv)) {
            if (!is.numeric(voltv)) {
                stop("Please enter a valid value for the volts.\n")
            }
            else {
                volts <- voltv
            }
        }
        if (!is.null(luxv)) {
            if (!is.numeric(luxv)) {
                stop("Please enter a valid value for the lux.\n")
            }
            else {
                lux <- luxv
            }
        }
    }
    nstreams <- length(index)
    if(warn){
    	if (nstreams > 100) {
        	cat("About to read and process", nstreams, "datasets.  Continue?  Press Enter or control-C to quit.\n")
        	scan(, quiet = TRUE)
    	}
    }
##break up processing if too long?
#
##choose a memory limit
#sizelim = floor(min(memory.limit(), 2000) * 1e6 /(300*12*20))
#
##read blocks of pages at a time as memory allows
#
#if (nstreams > sizelim ){
#cat("Splitting into ", ceiling(nstreams/sizelim), " chunks.\n")
#temp = list(data.out = NULL, page.timestamps = NULL, freq = freq)
#while(length(index) > 0){
#tempobj = read.bin(binfile, outfile = NULL, start = index[1], end = index[min(sizelim, length(index))], 
#    verbose , do.temp, calibrate, gain, 
#    offset, luxv, voltv, tformat,warn) 
#temp$data.out = rbind(temp$data.out, tempobj$data.out)
#temp$page.timestamps = c(temp$page.timestamps, tempobj$page.timestamps)
#
#index = index[- (1: min(sizelim, length(index)))]
#}
#    if (!(is.null(outfile))) {
#        save(temp, file = outfile)
#    }
#return(temp)
#}
#
    proc.file <- NULL
    start.proc.time <- Sys.time()
    data <- NULL
#skip to start of data
binfile = file(binfile, "rt")
tmpd <- readLines(binfile, n = 68)
#skip unread pages
replicate ( floor((min(bseq[index] + 11 ) - 68) / 10), is.character(readLines(binfile, n=10)))
    tmpd <- readLines(binfile, n = max(bseq[index]) + 11 - 68)
close(binfile)
    data <- strsplit(paste(tmpd[bseq[index] + 11 -68], collapse = ""), 
        "")[[1]]
    if (do.temp) {
        tdata <- tmpd[bseq[index] + 7]
        temp <- as.numeric(substring(tdata, 13, nchar(tdata)))
        temperature <- rep(temp, each = nobs)
    }
    # line below added for future beneficial gc
    rm(tmpd)
    cat("done file reading.  Processing...\n")
  #  data <- check.hex(data) #removed checks because taking too long, convert.hexstream should throw an error anyway.
    proc.file <- convert.hexstream(data)
    if (calibrate) {
        proc.file[1, ] <- (proc.file[1, ] * 100 - xoffset)/xgain
        proc.file[2, ] <- (proc.file[2, ] * 100 - yoffset)/ygain
        proc.file[3, ] <- (proc.file[3, ] * 100 - zoffset)/zgain
        proc.file[4, ] <- proc.file[4, ] * lux/volts
    }
    nn <- rep(timestamps[1:length(index)], each = length(freqseq)) + 
        freqseq
    proc.file <- t(proc.file)
    proc.file <- cbind(nn, proc.file)
#    rownames(proc.file) <- paste("obs.", 1:nrow(proc.file)) # strip out row labels - waste of memory
    cnames <- c("timestamp", "x", "y", "z", "light", "button")
    if (do.temp) {
        proc.file <- cbind(proc.file, temperature)
        colnames(proc.file) <- c(cnames, "temperature")
    }
    else {
        colnames(proc.file) <- cnames
    }
    end.proc.time <- Sys.time()
    cat("processing took:", format(round(as.difftime(end.proc.time - 
        start.proc.time), 3)), ".\n")
    processedfile <- list(data.out = proc.file, page.timestamps = timestampsc[index], freq= freq)
    if (is.null(outfile)) {
        return(processedfile)
    }
    else {
        save(processedfile, file = outfile)
    }
}

